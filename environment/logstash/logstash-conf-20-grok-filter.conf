filter {
  if [fields][server] == "apache" and [fields][logtype] == "ssl" {
    grok {
      # pattern based on COMMONAPACHELOG as available at
      # https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns
      match => { "message" => "\[%{HTTPDATE:timestamp}\] %{IPORHOST:clientip} %{NOTSPACE:SSL_PROTOCOL} %{NOTSPACE:SSL_CIPHER} \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" (?:%{NUMBER:bytes}|-)" }

      # we have no inner message to replace so leave this out
      #overwrite => [ "message" ]
    }
    date {
      # Format: 13/Jan/2016:11:55:40 +1300 (GROK: HTTPDATE)
      match => [ "timestamp", "dd/MMM/YYYY:HH:mm:ss Z"]
    }
  }

  if [fields][server] == "apache" and [fields][logtype] == "combined" {
    grok {
      match => { "message" => "%{COMBINEDAPACHELOG}" }

      # we have no inner message to replace so leave this out
      #overwrite => [ "message" ]
    }
    date {
      # Format: 13/Jan/2016:11:55:40 +1300 (GROK: HTTPDATE)
      match => [ "timestamp", "dd/MMM/YYYY:HH:mm:ss Z"]
    }
  }

  if [fields][server] == "apache" and [fields][logtype] == "errorlog" {
    grok {
      match => { "message" => "%{HTTPD24_ERRORLOG}" }

      # replace message with the inner message
      overwrite => [ "message" ]
    }
    date {
      # Format: Wed Jan 13 11:50:44.327650 2016 (GROK: HTTPDERROR_DATE)
      match => [ "timestamp", "EEE MMM dd HH:mm:ss.SSSSSS YYYY"]
    }
  }

  if [fields][server] == "freeradius" and [fields][logtype] == "linelog" {
    grok {
      # Parse freeradius linelog
      # Pattern as per /etc/raddb/mods-available/linelog
      # Access-Request = "\"%S\",\"%{reply:Packet-Type}\",\"%{reply:Chargeable-User-Identity}\",\"%{Operator-Name}\",\"%{Packet-Src-IP-Address}\",\"%{NAS-IP-Address}\",\"%{Client-Shortname}\",\"%{User-Name}\""
      # Example:
      # "2016-01-12 14:24:31","Access-Accept","496d42c40d40af717d9ea02c4b248a09ff58757a","reannz.co.nz","210.7.47.27","210.7.40.57","reannz.ac.nz-1","sam@sandstone.edu.au"
      match => { "message" => "\"%{TIMESTAMP_ISO8601:timestamp}\",\"%{USERNAME:reply_packet_type}\",\"(%{USERNAME:chargeable_user_identity})?\",\"(%{USERNAME:operator_name})?\",\"%{IP:packet_src_ip}\",\"(%{IP:nas_ip_address})?\",\"(%{USERNAME:client_short_name})?\",\"(%{EMAILADDRESS:username})?\"" }

      # we have no inner message to replace so leave this out
      #overwrite => [ "message" ]
    }
    if [fields][timezone] {
      mutate {
        add_field => { "timestamp_with_timezone" => "%{timestamp} %{[fields][timezone]}" }
      }
      date {
        match => [ "timestamp_with_timezone", "YYYY-MM-dd HH:mm:ss ZZZ"]
      }
    } else {
      date {
        match => [ "timestamp", "YYYY-MM-dd HH:mm:ss"]
      }
    }

    # parse username/realm
    if [username] {
      grok {
        # Parse username: get realm
        match => { "username" => "[^@]*@%{USERNAME:realm}" }
      }
      grok {
        # Parse realm: get country
        match => { "realm" => "[-_\.a-zA-Z0-9]*\.(?<realm_country>[-_a-zA-Z0-9]+)" }
      }
    }
    # END parse username/realm

    # add realm_country_is_local
    if [realm_country] {
      if [realm_country] == "${LOCAL_COUNTRY}" {
        mutate { add_field => { "realm_country_is_local" => 1 } }
      } else {
        mutate { add_field => { "realm_country_is_local" => 0 } }
      }
    }

    # parse operator_name/site
    if [operator_name] {
      grok {
        # Parse operator_name/site: get country
        match => { "operator_name" => "[-_\.a-zA-Z0-9]*\.(?<site_country>[-_a-zA-Z0-9]+)" }
      }
    }
    # END parse operator_name/site

    # add site_country_is_local
    if [site_country] {
      if [site_country] == "${LOCAL_COUNTRY}" {
        mutate { add_field => { "site_country_is_local" => 1 } }
      } else {
        mutate { add_field => { "site_country_is_local" => 0 } }
      }
    }

  }

}

